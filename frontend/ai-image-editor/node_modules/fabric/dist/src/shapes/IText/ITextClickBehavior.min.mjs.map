{"version":3,"file":"ITextClickBehavior.min.mjs","sources":["../../../../src/shapes/IText/ITextClickBehavior.ts"],"sourcesContent":["import type {\n  ObjectPointerEvents,\n  TPointerEvent,\n  TPointerEventInfo,\n} from '../../EventTypeDefs';\nimport { Point } from '../../Point';\nimport { invertTransform } from '../../util/misc/matrix';\nimport { DraggableTextDelegate } from './DraggableTextDelegate';\nimport type { ITextEvents } from './ITextBehavior';\nimport { ITextKeyBehavior } from './ITextKeyBehavior';\nimport type { TOptions } from '../../typedefs';\nimport type { TextProps, SerializedTextProps } from '../Text/Text';\nimport type { IText } from './IText';\n/**\n * `LEFT_CLICK === 0`\n */\nconst notALeftClick = (e: Event) => !!(e as MouseEvent).button;\n\nexport abstract class ITextClickBehavior<\n  Props extends TOptions<TextProps> = Partial<TextProps>,\n  SProps extends SerializedTextProps = SerializedTextProps,\n  EventSpec extends ITextEvents = ITextEvents,\n> extends ITextKeyBehavior<Props, SProps, EventSpec> {\n  protected draggableTextDelegate: DraggableTextDelegate;\n\n  initBehavior() {\n    // Initializes event handlers related to cursor or selection\n    this.on('mousedown', this._mouseDownHandler);\n    this.on('mouseup', this.mouseUpHandler);\n    this.on('mousedblclick', this.doubleClickHandler);\n    this.on('mousetripleclick', this.tripleClickHandler);\n\n    this.draggableTextDelegate = new DraggableTextDelegate(\n      this as unknown as IText,\n    );\n\n    super.initBehavior();\n  }\n\n  /**\n   * If this method returns true a mouse move operation over a text selection\n   * will not prevent the native mouse event allowing the browser to start a drag operation.\n   * shouldStartDragging can be read 'do not prevent default for mouse move event'\n   * To prevent drag and drop between objects both shouldStartDragging and onDragStart should return false\n   * @returns\n   */\n  shouldStartDragging() {\n    return this.draggableTextDelegate.isActive();\n  }\n\n  /**\n   * @public override this method to control whether instance should/shouldn't become a drag source,\n   * @see also {@link DraggableTextDelegate#isActive}\n   * To prevent drag and drop between objects both shouldStartDragging and onDragStart should return false\n   * @returns {boolean} should handle event\n   */\n  onDragStart(e: DragEvent) {\n    return this.draggableTextDelegate.onDragStart(e);\n  }\n\n  /**\n   * @public override this method to control whether instance should/shouldn't become a drop target\n   */\n  canDrop(e: DragEvent) {\n    return this.draggableTextDelegate.canDrop(e);\n  }\n\n  /**\n   * Default handler for double click, select a word\n   */\n  doubleClickHandler(options: TPointerEventInfo) {\n    if (!this.isEditing) {\n      return;\n    }\n    this.selectWord(this.getSelectionStartFromPointer(options.e));\n    this.renderCursorOrSelection();\n  }\n\n  /**\n   * Default handler for triple click, select a line\n   */\n  tripleClickHandler(options: TPointerEventInfo) {\n    if (!this.isEditing) {\n      return;\n    }\n    this.selectLine(this.getSelectionStartFromPointer(options.e));\n    this.renderCursorOrSelection();\n  }\n\n  /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */\n  _mouseDownHandler({ e, alreadySelected }: ObjectPointerEvents['mousedown']) {\n    if (\n      !this.canvas ||\n      !this.editable ||\n      notALeftClick(e) ||\n      this.getActiveControl()\n    ) {\n      return;\n    }\n\n    if (this.draggableTextDelegate.start(e)) {\n      return;\n    }\n\n    this.canvas.textEditingManager.register(this);\n\n    if (alreadySelected) {\n      this.inCompositionMode = false;\n      this.setCursorByClick(e);\n    }\n\n    if (this.isEditing) {\n      this.__selectionStartOnMouseDown = this.selectionStart;\n      if (this.selectionStart === this.selectionEnd) {\n        this.abortCursorAnimation();\n      }\n      this.renderCursorOrSelection();\n    }\n    this.selected ||= alreadySelected || this.isEditing;\n  }\n\n  /**\n   * standard handler for mouse up, overridable\n   * @private\n   */\n  mouseUpHandler({ e, transform }: ObjectPointerEvents['mouseup']) {\n    const didDrag = this.draggableTextDelegate.end(e);\n\n    if (this.canvas) {\n      this.canvas.textEditingManager.unregister(this);\n\n      const activeObject = this.canvas._activeObject;\n      if (activeObject && activeObject !== this) {\n        // avoid running this logic when there is an active object\n        // this because is possible with shift click and fast clicks,\n        // to rapidly deselect and reselect this object and trigger an enterEdit\n        return;\n      }\n    }\n\n    if (\n      !this.editable ||\n      (this.group && !this.group.interactive) ||\n      (transform && transform.actionPerformed) ||\n      notALeftClick(e) ||\n      didDrag\n    ) {\n      return;\n    }\n\n    if (this.selected && !this.getActiveControl()) {\n      this.enterEditing(e);\n      if (this.selectionStart === this.selectionEnd) {\n        this.initDelayedCursor(true);\n      } else {\n        this.renderCursorOrSelection();\n      }\n    }\n  }\n\n  /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {TPointerEvent} e Event object\n   */\n  setCursorByClick(e: TPointerEvent) {\n    const newSelection = this.getSelectionStartFromPointer(e),\n      start = this.selectionStart,\n      end = this.selectionEnd;\n    if (e.shiftKey) {\n      this.setSelectionStartEndWithShift(start, end, newSelection);\n    } else {\n      this.selectionStart = newSelection;\n      this.selectionEnd = newSelection;\n    }\n    if (this.isEditing) {\n      this._fireSelectionChanged();\n      this._updateTextarea();\n    }\n  }\n\n  /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {TPointerEvent} e Event object\n   * @return {Number} Index of a character\n   */\n  getSelectionStartFromPointer(e: TPointerEvent): number {\n    const mouseOffset = this.canvas!.getScenePoint(e)\n      .transform(invertTransform(this.calcTransformMatrix()))\n      .add(new Point(-this._getLeftOffset(), -this._getTopOffset()));\n    let height = 0,\n      charIndex = 0,\n      lineIndex = 0;\n\n    for (let i = 0; i < this._textLines.length; i++) {\n      if (height <= mouseOffset.y) {\n        height += this.getHeightOfLine(i);\n        lineIndex = i;\n        if (i > 0) {\n          charIndex +=\n            this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n        }\n      } else {\n        break;\n      }\n    }\n    const lineLeftOffset = Math.abs(this._getLineLeftOffset(lineIndex));\n    let width = lineLeftOffset;\n    const charLength = this._textLines[lineIndex].length;\n    const chars = this.__charBounds[lineIndex];\n    for (let j = 0; j < charLength; j++) {\n      // i removed something about flipX here, check.\n      const charWidth = chars[j].kernedWidth;\n      const widthAfter = width + charWidth;\n      if (mouseOffset.x <= widthAfter) {\n        // if the pointer is closer to the end of the char we increment charIndex\n        // in order to position the cursor after the char\n        if (\n          Math.abs(mouseOffset.x - widthAfter) <=\n          Math.abs(mouseOffset.x - width)\n        ) {\n          charIndex++;\n        }\n        break;\n      }\n      width = widthAfter;\n      charIndex++;\n    }\n\n    return Math.min(\n      // if object is horizontally flipped, mirror cursor location from the end\n      this.flipX ? charLength - charIndex : charIndex,\n      this._text.length,\n    );\n  }\n}\n"],"names":["notALeftClick","e","button","ITextClickBehavior","ITextKeyBehavior","constructor","super","arguments","_defineProperty","this","initBehavior","on","_mouseDownHandler","mouseUpHandler","doubleClickHandler","tripleClickHandler","draggableTextDelegate","DraggableTextDelegate","shouldStartDragging","isActive","onDragStart","canDrop","options","isEditing","selectWord","getSelectionStartFromPointer","renderCursorOrSelection","selectLine","_ref","alreadySelected","canvas","editable","getActiveControl","start","textEditingManager","register","inCompositionMode","setCursorByClick","__selectionStartOnMouseDown","selectionStart","selectionEnd","abortCursorAnimation","selected","_ref2","transform","didDrag","end","unregister","activeObject","_activeObject","group","interactive","actionPerformed","enterEditing","initDelayedCursor","newSelection","shiftKey","setSelectionStartEndWithShift","_fireSelectionChanged","_updateTextarea","mouseOffset","getScenePoint","invertTransform","calcTransformMatrix","add","Point","_getLeftOffset","_getTopOffset","height","charIndex","lineIndex","i","_textLines","length","y","getHeightOfLine","missingNewlineOffset","width","Math","abs","_getLineLeftOffset","charLength","chars","__charBounds","j","widthAfter","kernedWidth","x","min","flipX","_text"],"mappings":"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"}