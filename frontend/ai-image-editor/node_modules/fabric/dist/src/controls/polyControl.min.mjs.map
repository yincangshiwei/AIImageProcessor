{"version":3,"file":"polyControl.min.mjs","sources":["../../../src/controls/polyControl.ts"],"sourcesContent":["import { Point } from '../Point';\nimport { Control } from './Control';\nimport type { TMat2D } from '../typedefs';\nimport type { Polyline } from '../shapes/Polyline';\nimport { multiplyTransformMatrices } from '../util/misc/matrix';\nimport type {\n  TModificationEvents,\n  TPointerEvent,\n  Transform,\n  TransformActionHandler,\n} from '../EventTypeDefs';\nimport { wrapWithFireEvent } from './wrapWithFireEvent';\nimport { sendPointToPlane } from '../util/misc/planeChange';\nimport { MODIFY_POLY } from '../constants';\n\nconst ACTION_NAME: TModificationEvents = MODIFY_POLY;\n\ntype TTransformAnchor = Transform & { pointIndex: number };\n\n/**\n * This function locates the controls.\n * It'll be used both for drawing and for interaction.\n */\nexport const createPolyPositionHandler = (pointIndex: number) => {\n  return function (dim: Point, finalMatrix: TMat2D, polyObject: Polyline) {\n    const { points, pathOffset } = polyObject;\n    return new Point(points[pointIndex])\n      .subtract(pathOffset)\n      .transform(\n        multiplyTransformMatrices(\n          polyObject.getViewportTransform(),\n          polyObject.calcTransformMatrix(),\n        ),\n      );\n  };\n};\n\n/**\n * This function defines what the control does.\n * It'll be called on every mouse move after a control has been clicked and is being dragged.\n * The function receives as argument the mouse event, the current transform object\n * and the current position in canvas coordinate `transform.target` is a reference to the\n * current object being transformed.\n */\nexport const polyActionHandler = (\n  eventData: TPointerEvent,\n  transform: TTransformAnchor,\n  x: number,\n  y: number,\n) => {\n  const { target, pointIndex } = transform;\n  const poly = target as Polyline;\n  const mouseLocalPosition = sendPointToPlane(\n    new Point(x, y),\n    undefined,\n    poly.calcOwnMatrix(),\n  );\n\n  poly.points[pointIndex] = mouseLocalPosition.add(poly.pathOffset);\n  poly.setDimensions();\n  poly.set('dirty', true);\n  return true;\n};\n\n/**\n * Keep the polygon in the same position when we change its `width`/`height`/`top`/`left`.\n */\nexport const factoryPolyActionHandler = (\n  pointIndex: number,\n  fn: TransformActionHandler<TTransformAnchor>,\n) => {\n  return function (\n    eventData: TPointerEvent,\n    transform: Transform,\n    x: number,\n    y: number,\n  ) {\n    const poly = transform.target as Polyline,\n      anchorPoint = new Point(\n        poly.points[(pointIndex > 0 ? pointIndex : poly.points.length) - 1],\n      ),\n      anchorPointInParentPlane = anchorPoint\n        .subtract(poly.pathOffset)\n        .transform(poly.calcOwnMatrix()),\n      actionPerformed = fn(eventData, { ...transform, pointIndex }, x, y);\n\n    const newAnchorPointInParentPlane = anchorPoint\n      .subtract(poly.pathOffset)\n      .transform(poly.calcOwnMatrix());\n\n    const diff = newAnchorPointInParentPlane.subtract(anchorPointInParentPlane);\n    poly.left -= diff.x;\n    poly.top -= diff.y;\n\n    return actionPerformed;\n  };\n};\n\nexport const createPolyActionHandler = (pointIndex: number) =>\n  wrapWithFireEvent(\n    ACTION_NAME,\n    factoryPolyActionHandler(pointIndex, polyActionHandler),\n  );\n\nexport function createPolyControls(\n  poly: Polyline,\n  options?: Partial<Control>,\n): Record<string, Control>;\nexport function createPolyControls(\n  numOfControls: number,\n  options?: Partial<Control>,\n): Record<string, Control>;\nexport function createPolyControls(\n  arg0: number | Polyline,\n  options: Partial<Control> = {},\n) {\n  const controls = {} as Record<string, Control>;\n  for (\n    let idx = 0;\n    idx < (typeof arg0 === 'number' ? arg0 : arg0.points.length);\n    idx++\n  ) {\n    controls[`p${idx}`] = new Control({\n      actionName: ACTION_NAME,\n      positionHandler: createPolyPositionHandler(idx),\n      actionHandler: createPolyActionHandler(idx),\n      ...options,\n    });\n  }\n  return controls;\n}\n"],"names":["ACTION_NAME","MODIFY_POLY","createPolyPositionHandler","pointIndex","dim","finalMatrix","polyObject","points","pathOffset","Point","subtract","transform","multiplyTransformMatrices","getViewportTransform","calcTransformMatrix","polyActionHandler","eventData","x","y","target","poly","mouseLocalPosition","sendPointToPlane","undefined","calcOwnMatrix","add","setDimensions","set","factoryPolyActionHandler","fn","anchorPoint","length","anchorPointInParentPlane","actionPerformed","_objectSpread","diff","left","top","createPolyActionHandler","wrapWithFireEvent","createPolyControls","arg0","options","arguments","controls","idx","concat","Control","actionName","positionHandler","actionHandler"],"mappings":"qaAeA,MAAMA,EAAmCC,EAQ5BC,EAA6BC,GACjC,SAAUC,EAAYC,EAAqBC,GAChD,MAAMC,OAAEA,EAAMC,WAAEA,GAAeF,EAC/B,OAAO,IAAIG,EAAMF,EAAOJ,IACrBO,SAASF,GACTG,UACCC,EACEN,EAAWO,uBACXP,EAAWQ,yBAaRC,EAAoBA,CAC/BC,EACAL,EACAM,EACAC,KAEA,MAAMC,OAAEA,EAAMhB,WAAEA,GAAeQ,EACzBS,EAAOD,EACPE,EAAqBC,EACzB,IAAIb,EAAMQ,EAAGC,QACbK,EACAH,EAAKI,iBAMP,OAHAJ,EAAKb,OAAOJ,GAAckB,EAAmBI,IAAIL,EAAKZ,YACtDY,EAAKM,gBACLN,EAAKO,IAAI,SAAS,IACX,CAAI,EAMAC,EAA2BA,CACtCzB,EACA0B,IAEO,SACLb,EACAL,EACAM,EACAC,GAEA,MAAME,EAAOT,EAAUQ,OACrBW,EAAc,IAAIrB,EAChBW,EAAKb,QAAQJ,EAAa,EAAIA,EAAaiB,EAAKb,OAAOwB,QAAU,IAEnEC,EAA2BF,EACxBpB,SAASU,EAAKZ,YACdG,UAAUS,EAAKI,iBAClBS,EAAkBJ,EAAGb,EAASkB,EAAAA,EAAA,GAAOvB,GAAS,GAAA,CAAER,eAAcc,EAAGC,GAM7DiB,EAJ8BL,EACjCpB,SAASU,EAAKZ,YACdG,UAAUS,EAAKI,iBAEuBd,SAASsB,GAIlD,OAHAZ,EAAKgB,MAAQD,EAAKlB,EAClBG,EAAKiB,KAAOF,EAAKjB,EAEVe,GAIEK,EAA2BnC,GACtCoC,EACEvC,EACA4B,EAAyBzB,EAAYY,IAWlC,SAASyB,EACdC,GAEA,IADAC,EAAyBC,UAAAZ,OAAA,QAAAR,IAAAoB,UAAA,GAAAA,UAAA,GAAG,CAAA,EAE5B,MAAMC,EAAW,CAAA,EACjB,IACE,IAAIC,EAAM,EACVA,GAAuB,iBAATJ,EAAoBA,EAAOA,EAAKlC,OAAOwB,QACrDc,IAEAD,EAAQ,IAAAE,OAAKD,IAAS,IAAIE,EAAOb,EAAA,CAC/Bc,WAAYhD,EACZiD,gBAAiB/C,EAA0B2C,GAC3CK,cAAeZ,EAAwBO,IACpCH,IAGP,OAAOE,CACT"}